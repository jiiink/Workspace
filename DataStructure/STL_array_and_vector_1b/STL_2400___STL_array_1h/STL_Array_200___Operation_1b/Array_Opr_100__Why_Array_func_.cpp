/* --------------- Why we use array ---------------------
퍼포먼스가 중요한 실제 어플리케이션에서는 벡터가 가지고 있는 문제점은 다음과 같습니다.
1. 생성과 소멸을 하는데 드는 비용이 만만치 않습니다. 이 오버헤드는 특히
   사용해야 하는 벡터의 수가 많으면 많을수록 증가합니다.
2. 내부에 element를 할당시 런타임에 실행합니다. 벡터가 동적배열이기 때문에
   너무나도 당연한 이야기이지만, 역시 퍼포먼스에는 안좋은 영향을 미칩니다.
3. 벡터 객체는 대부분의 경우 32 바이트를 차지하므로 메모리를 비효율적으로 사용하게 됩니다.
4. 동적으로 증가하거나 감소하는 경우 불필요한 벡터간 복사가 일어납니다.
   (이 부분은 C++11 에서 move semantics 라는 개념에 의해 극복되었습니다.)

   기존의 배열은 위에서 언급한 벡터에서 발생하는 추가의 헛선질(오버헤드)가 없습니다.
   컴파일타임에 미리 그 사이즈를 결정하기 때문에 비용은 있을 수가 없죠.
   그러나 벡터가 가져오는 장점은 당연히 포기해야 합니다.
   배열 명이 그 첫번째 원소를 가르키는 포인터로 묵시적인 형변환이 허용되므로,
   보안상의 문제 또한 있습니다.

   이런 문제를 해결하기 위해 C++11에서는 기존의 컨테이너와 유사하면서 정적인 배열을
   선언하기 위해 array 가 채택되었습니다.
   이를 통해 벡터의 장점은 그대로 취하는 한편, 정해진 크기의 정적 배열을 만들 수 있습니다.

   array의 좋은 점 가운데 하나는 벡터에서와 같이 상수시간에 random  access 가 가능합니다.
   또한, 메모리 측면에서 볼 때, 벡터가 free-store 라고 불리우는 영역에 엘리먼트를
   비연속적으로 배치하여 사용하는 것과는 다르게 array는 스택 공간에
   연속적으로 엘리먼트를 배치합니다. 또한 array 는 생성자, 소멸자, 복사생성자,
   대입연산자를 지원합니다. C++11 표준으로 승인된 array 를 사용해 봅시다.

*/

#include <bits/stdc++.h>
using namespace std ;

int main() {
    array <int,    5> a1   { {14, 2, 5, 7, 23} };      // double-braces required
    array <int,    3> a2 = { 11, 22, 33};    // except after =
    array <string, 4> a3 = { {string("a"), "b", "PNU", "Beer"}  };

    sort(a1.begin(), a1.end());
    reverse_copy(a2.begin(), a2.end(), ostream_iterator<int>(cout, "---"));

    // ranged for loop is supported
    for(auto& s: a1) cout << "\n a1 s = " <<  s << ' ';
    for(auto& s: a2) cout << "\n a2 s = " <<  s << ' ';
    for(auto& s: a3) cout << "\n a3 s = " <<  s << ' ';

    cout << "\n 실험이 끝났습니다. \n" ;
}
